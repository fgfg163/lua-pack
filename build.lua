do
package.preload["index"] = load("require 'string-split'\nlocal json = require 'json'\nlocal path = require 'path'\nconsole = require 'console'\nlocal program = require 'commander'\n\nprogram.option('-e, --entry', 'main.lua')\nprogram.option('-o, --output', 'main-min.lua')\nprogram.option('-sm, --source-code-mode', false)\nprogram.parse(arg)\nlocal loadedList = {}\nlocal preloadList = {}\n\nlocal outputFile, err = io.open(program.params.output, 'w')\nif err then\n  console.log(err)\n  if outputFile then\n    outputFile:close()\n  end\n  os.exit()\nend\noutputFile:close()\n\nlocal function readFileToTable(file)\n  local result = {}\n  for i = 0, math.huge do\n    local line = file:read('*line')\n    table.insert(result, line)\n    if line == nil then\n      break\n    end\n  end\n  return result\nend\n\nlocal entryFile, err = io.open(program.params.entry, 'r')\nif err then\n  console.log(err)\n  if file then\n    entryFile:close()\n  end\n  os.exit()\nend\nlocal entryData = entryFile:read('*all')\nentryFile:close()\ntable.insert(preloadList, program.params.entry)\npreloadList[program.params.entry] = program.params.entry\n\nwhile #preloadList > 0 do\n  local preloadPath = preloadList[1]\n  local preloadPathName = preloadPath:gsub('.lua$', '')\n  table.remove(preloadList, 1)\n  local entryFile, err = io.open(preloadPath, 'r')\n  if not err then\n    console.log('build file: ' .. preloadPath)\n    local requireTable = readFileToTable(entryFile)\n    local requireSource = table.concat(requireTable, '\\n')\n    if program.params['source-code-mode'] then\n      if type(program.params['source-code-mode']) == 'string' then\n        requireSource = 'do\\npackage[' .. json.encode(program['source-code-mode']) .. '][\"' .. preloadPathName .. '\"] = { path = \"' .. preloadPath .. '\", source = ' .. json.encode(requireSource) .. ' }' .. '\\nend'\n      else\n        requireSource = 'do\\npackage.sourceCode[\"' .. preloadPathName .. '\"] = { path = \"' .. preloadPath .. '\", source = ' .. json.encode(requireSource) .. ' }' .. '\\nend'\n      end\n    else\n      requireSource = 'do\\npackage.preload[\"' .. preloadPathName .. '\"] = load(' .. json.encode(requireSource) .. ',\"@' .. preloadPath .. '\", \"bt\", _ENV)' .. '\\nend'\n    end\n    table.insert(loadedList, requireSource)\n\n    -- 寻找文件require的内容\n    for k, v in ipairs(requireTable) do\n      for value in v:gmatch('require%s*%(?[\"\\']([%w-_./\\\\]+)[\"\\']%)?') do\n        local subRequirePath = value\n        if not value:match('.lua$') then\n          subRequirePath = subRequirePath .. '.lua'\n        end\n        if not preloadList[subRequirePath] then\n          table.insert(preloadList, subRequirePath)\n          preloadList[subRequirePath] = subRequirePath\n        end\n      end\n    end\n  else\n    console.log(err)\n  end\n  if entryFile then\n    entryFile:close()\n  end\nend\n\nlocal outputFile, err = io.open(program.params.output, 'w')\nif err then\n  console.log(err)\n  if outputFile then\n    outputFile:close()\n  end\n  os.exit()\nend\n\n\nif program.params['source-code-mode'] then\n  if type(program.params['source-code-mode']) == 'string' then\n    outputFile:write('do\\npackage[\"' .. program.params['source-code-mode'] .. '\"] = {}\\nend\\n')\n  else\n    outputFile:write('do\\npackage.sourceCode = {}\\nend\\n')\n  end\nend\nfor k, v in ipairs(loadedList) do\n  outputFile:write(v)\n  outputFile:write('\\n')\nend\noutputFile:write('\\nrequire(\"' .. program.params.entry:gsub('.lua$', '') .. '\")\\n')\noutputFile:close()","@index.lua", "bt", _ENV)
end
do
package.preload["string-split"] = load("-- 字符串分割\n-- 防止有人覆盖 string 方法\nlocal myString = {}\nlocal tmpString = {}\nfor key, value in pairs(string) do\n  tmpString[key] = value\nend\ntmpString.split = myString.split or function(str, d)\n  if str == '' and d ~= '' then\n    return { str }\n  elseif str ~= '' and d == '' then\n    local lst = {}\n    for key = 1, tmpString.len(str) do\n      table.insert(lst, tmpString.sub(str, key, 1))\n    end\n    return lst\n  else\n    local lst = {}\n    local n = tmpString.len(str) --长度\n    local start = 1\n    while start <= n do\n      local i = tmpString.find(str, d, start) -- find 'next' 0\n      if i == nil then\n        table.insert(lst, tmpString.sub(str, start, n))\n        break\n      end\n      table.insert(lst, tmpString.sub(str, start, i - 1))\n      if i == n then\n        table.insert(lst, '')\n        break\n      end\n      start = i + 1\n    end\n    return lst\n  end\nend\nfor key, value in pairs(tmpString) do\n  string[key] = string[key] or value\nend\nreturn myString","@string-split.lua", "bt", _ENV)
end
do
package.preload["json"] = load("--\n-- json.lua\n--\n-- Copyright (c) 2018 rxi\n--\n-- Permission is hereby granted, free of charge, to any person obtaining a copy of\n-- this software and associated documentation files (the \"Software\"), to deal in\n-- the Software without restriction, including without limitation the rights to\n-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n-- of the Software, and to permit persons to whom the Software is furnished to do\n-- so, subject to the following conditions:\n--\n-- The above copyright notice and this permission notice shall be included in all\n-- copies or substantial portions of the Software.\n--\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-- SOFTWARE.\n--\n\nlocal json = { _version = \"0.1.1\" }\n\n-------------------------------------------------------------------------------\n-- Encode\n-------------------------------------------------------------------------------\n\nlocal encode\n\nlocal escape_char_map = {\n  [ \"\\\\\" ] = \"\\\\\\\\\",\n  [ \"\\\"\" ] = \"\\\\\\\"\",\n  [ \"\\b\" ] = \"\\\\b\",\n  [ \"\\f\" ] = \"\\\\f\",\n  [ \"\\n\" ] = \"\\\\n\",\n  [ \"\\r\" ] = \"\\\\r\",\n  [ \"\\t\" ] = \"\\\\t\",\n}\n\nlocal escape_char_map_inv = { [ \"\\\\/\" ] = \"/\" }\nfor k, v in pairs(escape_char_map) do\n  escape_char_map_inv[v] = k\nend\n\n\nlocal function escape_char(c)\n  return escape_char_map[c] or string.format(\"\\\\u%04x\", c:byte())\nend\n\n\nlocal function encode_nil(val)\n  return \"null\"\nend\n\n\nlocal function encode_table(val, stack)\n  local res = {}\n  stack = stack or {}\n\n  -- Circular reference?\n  if stack[val] then error(\"circular reference\") end\n\n  stack[val] = true\n\n  if val[1] ~= nil or next(val) == nil then\n    -- Treat as array -- check keys are valid and it is not sparse\n    local n = 0\n    for k in pairs(val) do\n      if type(k) ~= \"number\" then\n        error(\"invalid table: mixed or invalid key types\")\n      end\n      n = n + 1\n    end\n    if n ~= #val then\n      error(\"invalid table: sparse array\")\n    end\n    -- Encode\n    for i, v in ipairs(val) do\n      table.insert(res, encode(v, stack))\n    end\n    stack[val] = nil\n    return \"[\" .. table.concat(res, \",\") .. \"]\"\n\n  else\n    -- Treat as an object\n    for k, v in pairs(val) do\n      if type(k) ~= \"string\" then\n        error(\"invalid table: mixed or invalid key types\")\n      end\n      table.insert(res, encode(k, stack) .. \":\" .. encode(v, stack))\n    end\n    stack[val] = nil\n    return \"{\" .. table.concat(res, \",\") .. \"}\"\n  end\nend\n\n\nlocal function encode_string(val)\n  return '\"' .. val:gsub('[%z\\1-\\31\\\\\"]', escape_char) .. '\"'\nend\n\n\nlocal function encode_number(val)\n  -- Check for NaN, -inf and inf\n  if val ~= val or val <= -math.huge or val >= math.huge then\n    error(\"unexpected number value '\" .. tostring(val) .. \"'\")\n  end\n  return string.format(\"%.14g\", val)\nend\n\n\nlocal type_func_map = {\n  [ \"nil\"     ] = encode_nil,\n  [ \"table\"   ] = encode_table,\n  [ \"string\"  ] = encode_string,\n  [ \"number\"  ] = encode_number,\n  [ \"boolean\" ] = tostring,\n}\n\n\nencode = function(val, stack)\n  local t = type(val)\n  local f = type_func_map[t]\n  if f then\n    return f(val, stack)\n  end\n  error(\"unexpected type '\" .. t .. \"'\")\nend\n\n\nfunction json.encode(val)\n  return ( encode(val) )\nend\n\n\n-------------------------------------------------------------------------------\n-- Decode\n-------------------------------------------------------------------------------\n\nlocal parse\n\nlocal function create_set(...)\n  local res = {}\n  for i = 1, select(\"#\", ...) do\n    res[ select(i, ...) ] = true\n  end\n  return res\nend\n\nlocal space_chars   = create_set(\" \", \"\\t\", \"\\r\", \"\\n\")\nlocal delim_chars   = create_set(\" \", \"\\t\", \"\\r\", \"\\n\", \"]\", \"}\", \",\")\nlocal escape_chars  = create_set(\"\\\\\", \"/\", '\"', \"b\", \"f\", \"n\", \"r\", \"t\", \"u\")\nlocal literals      = create_set(\"true\", \"false\", \"null\")\n\nlocal literal_map = {\n  [ \"true\"  ] = true,\n  [ \"false\" ] = false,\n  [ \"null\"  ] = nil,\n}\n\n\nlocal function next_char(str, idx, set, negate)\n  for i = idx, #str do\n    if set[str:sub(i, i)] ~= negate then\n      return i\n    end\n  end\n  return #str + 1\nend\n\n\nlocal function decode_error(str, idx, msg)\n  local line_count = 1\n  local col_count = 1\n  for i = 1, idx - 1 do\n    col_count = col_count + 1\n    if str:sub(i, i) == \"\\n\" then\n      line_count = line_count + 1\n      col_count = 1\n    end\n  end\n  error( string.format(\"%s at line %d col %d\", msg, line_count, col_count) )\nend\n\n\nlocal function codepoint_to_utf8(n)\n  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa\n  local f = math.floor\n  if n <= 0x7f then\n    return string.char(n)\n  elseif n <= 0x7ff then\n    return string.char(f(n / 64) + 192, n % 64 + 128)\n  elseif n <= 0xffff then\n    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)\n  elseif n <= 0x10ffff then\n    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,\n                       f(n % 4096 / 64) + 128, n % 64 + 128)\n  end\n  error( string.format(\"invalid unicode codepoint '%x'\", n) )\nend\n\n\nlocal function parse_unicode_escape(s)\n  local n1 = tonumber( s:sub(3, 6),  16 )\n  local n2 = tonumber( s:sub(9, 12), 16 )\n  -- Surrogate pair?\n  if n2 then\n    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)\n  else\n    return codepoint_to_utf8(n1)\n  end\nend\n\n\nlocal function parse_string(str, i)\n  local has_unicode_escape = false\n  local has_surrogate_escape = false\n  local has_escape = false\n  local last\n  for j = i + 1, #str do\n    local x = str:byte(j)\n\n    if x < 32 then\n      decode_error(str, j, \"control character in string\")\n    end\n\n    if last == 92 then -- \"\\\\\" (escape char)\n      if x == 117 then -- \"u\" (unicode escape sequence)\n        local hex = str:sub(j + 1, j + 5)\n        if not hex:find(\"%x%x%x%x\") then\n          decode_error(str, j, \"invalid unicode escape in string\")\n        end\n        if hex:find(\"^[dD][89aAbB]\") then\n          has_surrogate_escape = true\n        else\n          has_unicode_escape = true\n        end\n      else\n        local c = string.char(x)\n        if not escape_chars[c] then\n          decode_error(str, j, \"invalid escape char '\" .. c .. \"' in string\")\n        end\n        has_escape = true\n      end\n      last = nil\n\n    elseif x == 34 then -- '\"' (end of string)\n      local s = str:sub(i + 1, j - 1)\n      if has_surrogate_escape then\n        s = s:gsub(\"\\\\u[dD][89aAbB]..\\\\u....\", parse_unicode_escape)\n      end\n      if has_unicode_escape then\n        s = s:gsub(\"\\\\u....\", parse_unicode_escape)\n      end\n      if has_escape then\n        s = s:gsub(\"\\\\.\", escape_char_map_inv)\n      end\n      return s, j + 1\n\n    else\n      last = x\n    end\n  end\n  decode_error(str, i, \"expected closing quote for string\")\nend\n\n\nlocal function parse_number(str, i)\n  local x = next_char(str, i, delim_chars)\n  local s = str:sub(i, x - 1)\n  local n = tonumber(s)\n  if not n then\n    decode_error(str, i, \"invalid number '\" .. s .. \"'\")\n  end\n  return n, x\nend\n\n\nlocal function parse_literal(str, i)\n  local x = next_char(str, i, delim_chars)\n  local word = str:sub(i, x - 1)\n  if not literals[word] then\n    decode_error(str, i, \"invalid literal '\" .. word .. \"'\")\n  end\n  return literal_map[word], x\nend\n\n\nlocal function parse_array(str, i)\n  local res = {}\n  local n = 1\n  i = i + 1\n  while 1 do\n    local x\n    i = next_char(str, i, space_chars, true)\n    -- Empty / end of array?\n    if str:sub(i, i) == \"]\" then\n      i = i + 1\n      break\n    end\n    -- Read token\n    x, i = parse(str, i)\n    res[n] = x\n    n = n + 1\n    -- Next token\n    i = next_char(str, i, space_chars, true)\n    local chr = str:sub(i, i)\n    i = i + 1\n    if chr == \"]\" then break end\n    if chr ~= \",\" then decode_error(str, i, \"expected ']' or ','\") end\n  end\n  return res, i\nend\n\n\nlocal function parse_object(str, i)\n  local res = {}\n  i = i + 1\n  while 1 do\n    local key, val\n    i = next_char(str, i, space_chars, true)\n    -- Empty / end of object?\n    if str:sub(i, i) == \"}\" then\n      i = i + 1\n      break\n    end\n    -- Read key\n    if str:sub(i, i) ~= '\"' then\n      decode_error(str, i, \"expected string for key\")\n    end\n    key, i = parse(str, i)\n    -- Read ':' delimiter\n    i = next_char(str, i, space_chars, true)\n    if str:sub(i, i) ~= \":\" then\n      decode_error(str, i, \"expected ':' after key\")\n    end\n    i = next_char(str, i + 1, space_chars, true)\n    -- Read value\n    val, i = parse(str, i)\n    -- Set\n    res[key] = val\n    -- Next token\n    i = next_char(str, i, space_chars, true)\n    local chr = str:sub(i, i)\n    i = i + 1\n    if chr == \"}\" then break end\n    if chr ~= \",\" then decode_error(str, i, \"expected '}' or ','\") end\n  end\n  return res, i\nend\n\n\nlocal char_func_map = {\n  [ '\"' ] = parse_string,\n  [ \"0\" ] = parse_number,\n  [ \"1\" ] = parse_number,\n  [ \"2\" ] = parse_number,\n  [ \"3\" ] = parse_number,\n  [ \"4\" ] = parse_number,\n  [ \"5\" ] = parse_number,\n  [ \"6\" ] = parse_number,\n  [ \"7\" ] = parse_number,\n  [ \"8\" ] = parse_number,\n  [ \"9\" ] = parse_number,\n  [ \"-\" ] = parse_number,\n  [ \"t\" ] = parse_literal,\n  [ \"f\" ] = parse_literal,\n  [ \"n\" ] = parse_literal,\n  [ \"[\" ] = parse_array,\n  [ \"{\" ] = parse_object,\n}\n\n\nparse = function(str, idx)\n  local chr = str:sub(idx, idx)\n  local f = char_func_map[chr]\n  if f then\n    return f(str, idx)\n  end\n  decode_error(str, idx, \"unexpected character '\" .. chr .. \"'\")\nend\n\n\nfunction json.decode(str)\n  if type(str) ~= \"string\" then\n    error(\"expected argument of type string, got \" .. type(str))\n  end\n  local res, idx = parse(str, next_char(str, 1, space_chars, true))\n  idx = next_char(str, idx, space_chars, true)\n  if idx <= #str then\n    decode_error(str, idx, \"trailing garbage\")\n  end\n  return res\nend\n\n\nreturn json","@json.lua", "bt", _ENV)
end
do
package.preload["path"] = load("local path = {}\npath.separator = string.find(package.path, '/') and '/' or '\\\\'\npath.basename = function(thePath)\n  thePath = string.gsub(thePath, '\\\\', '/')\n  thePath = string.gsub(thePath, '//+', '/')\n  local thePathArray = string.split(thePath, '/')\n  local res = table.remove(thePathArray)\n  return res\nend\npath.dirname = function(thePath)\n  thePath = string.gsub(thePath, '\\\\', '/')\n  thePath = string.gsub(thePath, '//+', '/')\n  local thePathArray = string.split(thePath, '/')\n  table.remove(thePathArray)\n  return table.concat(thePathArray, path.separator)\nend\npath.extname = function()\nend\npath.join = function(...)\n  local pathArray = { ... }\n  local resultPathArray = {}\n  for key = 1, #pathArray do\n    if pathArray[key] ~= '' then\n      if type(pathArray[key]) ~= 'string' then\n        error('bad argument #' .. key .. ' to \\'path.join\\' (string expected, got ' .. type(pathArray[key]) .. ')', 2)\n      end\n      local thePath = string.gsub(pathArray[key], '\\\\', '/')\n      thePath = string.gsub(thePath, '//+', '/')\n      local thePathArray = string.split(thePath, '/')\n      for key2 = 1, #thePathArray do\n        local theName = thePathArray[key2]\n        if theName == '' and #resultPathArray > 0 then\n        elseif theName == '.' and #resultPathArray > 0 then\n        elseif theName == '..' and #resultPathArray == 1 and resultPathArray[1] == '' then\n          table.remove(resultPathArray)\n        elseif theName == '..' and #resultPathArray == 1 and resultPathArray[1] == '.' then\n          resultPathArray = { '..' }\n        elseif theName == '..' and #resultPathArray > 0 then\n          table.remove(resultPathArray)\n        else\n          table.insert(resultPathArray, theName)\n        end\n      end\n    end\n  end\n  return table.concat(resultPathArray, path.separator)\nend\npath.relative = function()\nend\npath.resolve = function(...)\n  local pathArray = { ... }\n  local resultPathArray = {}\n  for key = 1, #pathArray do\n    if pathArray[key] ~= '' then\n      local thePath = string.gsub(string.gsub(pathArray[key], '\\\\', '/'), '/$', '')\n      thePath = string.gsub(thePath, '//+', '/')\n      local thePathArray = string.split(thePath, '/')\n      for key2 = 1, #thePathArray do\n        local theName = thePathArray[key2]\n        if theName == '' and key2 == 1 then\n          resultPathArray = { '' }\n        elseif theName == '.' and #resultPathArray > 0 then\n        elseif theName == '..' and #resultPathArray == 1 and resultPathArray[1] == '' then\n          table.remove(resultPathArray)\n        elseif theName == '..' and #resultPathArray == 1 and resultPathArray[1] == '.' then\n          resultPathArray = { '..' }\n        elseif theName == '..' and #resultPathArray > 0 then\n          table.remove(resultPathArray)\n        else\n          table.insert(resultPathArray, theName)\n        end\n      end\n    end\n  end\n  return table.concat(resultPathArray, path.separator)\nend\nreturn path","@path.lua", "bt", _ENV)
end
do
package.preload["console"] = load("local console = console or {}\nlocal __console = {}\nfor key, value in pairs(console) do\n  __console[key] = value\nend\n\n\nlocal getLength = table.length or function(target)\n  local length = 0\n  for k, v in ipairs(target) do\n    length = k\n  end\n  return length\nend\n\nlocal isArray = table.isArray or function(tab)\n  if (type(tab) ~= \"table\") then\n    return false\n  end\n  local length = getLength(tab)\n  for k, v in pairs(tab) do\n    if ((type(k) ~= \"number\") or (k > length)) then\n      return false\n    end\n  end\n  return true\nend\n\n\nlocal function runTable(tab, space)\n  if type(tab) == 'number' then\n    return { tostring(tab) }\n  end\n  if type(tab) == 'string' then\n    if string.len(tab) > 1000 then\n      return { '\"' .. string.sub(tab, 1, 1000) .. '...\"' }\n    end\n    return { '\"' .. tab .. '\"' }\n  end\n  if type(tab) == 'boolean' then\n    if (tab) then\n      return { 'true' }\n    else\n      return { 'false' }\n    end\n  end\n  if type(tab) ~= 'table' then\n    return { '(' .. type(tab) .. ')' }\n  end\n  if type(space) == 'number' then\n    space = string.rep(' ', space)\n  end\n  if type(space) ~= 'string' then\n    space = ''\n  end\n\n  local resultStrList = {}\n  local newTabPairs = {}\n  local newTabPairsKeys = {}\n  local tabIsArray = true\n  local tabLength = 0\n  local hasSubTab = false\n\n  -- 将 table 的数组部分取出\n  for k, v in ipairs(tab) do\n    tabLength = k\n    table.insert(newTabPairs, { k, runTable(v, space) })\n    if (type(v) == 'table') then\n      hasSubTab = true\n    end\n  end\n\n  -- 将 table 的 map 部分取出，并按照字典顺序排序\n  for k, v in pairs(tab) do\n    if type(k) ~= 'number' or k > tabLength or k < 1 then\n      tabIsArray = false\n      table.insert(newTabPairsKeys, k)\n      if (type(v) == 'table') then\n        hasSubTab = true\n      end\n    end\n  end\n\n  table.sort(newTabPairsKeys)\n  for _, k in ipairs(newTabPairsKeys) do\n    table.insert(newTabPairs, { k, runTable(tab[k], space) })\n  end\n\n  if (tabIsArray) then\n    local newTabArr = newTabPairs\n\n    if (hasSubTab) then\n      table.insert(resultStrList, '[')\n      for k, v in ipairs(newTabArr) do\n        local v2Length = getLength(v[2])\n        v[2][v2Length] = v[2][v2Length] .. ','\n        for k2, v2 in ipairs(v[2]) do\n          table.insert(resultStrList, space .. v2)\n        end\n      end\n      table.insert(resultStrList, ']')\n    else\n      local theStr = {}\n      for k, v in ipairs(newTabPairs) do\n        table.insert(theStr, v[2][1])\n      end\n      local childStr = table.concat(theStr, ', ')\n      table.insert(resultStrList, '[' .. childStr .. ']')\n    end\n  else\n    local newTabArr = newTabPairs\n\n    table.insert(resultStrList, '{')\n    for k, v in ipairs(newTabArr) do\n      v[2][1] = v[1] .. ': ' .. v[2][1]\n      local v2Length = getLength(v[2])\n      v[2][v2Length] = v[2][v2Length] .. ','\n      for k2, v2 in ipairs(v[2]) do\n        table.insert(resultStrList, space .. v2 .. '')\n      end\n    end\n    table.insert(resultStrList, '}')\n  end\n  return resultStrList\nend\n\n\n__console.log = __console.log or function(obj)\n  local info = debug.getinfo(2, 'Sl')\n  local lineInfo = ''\n  if info.currentline then\n    lineInfo = info.source .. ': ' .. info.currentline .. ': '\n  end\n  local js = table.concat(runTable(obj, 2), \"\\n\")\n  print(lineInfo .. '\\n' .. js)\n  return js\nend\n\n__console.getJsStr = function(obj)\n  return table.concat(runTable(obj, 2), \",\\n\")\nend\n\n__console.color = function(value)\n  local resultStr = ''\n  local color = getColor(value[1], value[2])\n  local oldColor = value[3]\n  local colorStr = string.format('0x%06x', color)\n  local oldColorStr = string.format('0x%06x', oldColor)\n  value[3] = oldColorStr\n  if (color == oldColor) then\n    resultStr = resultStr .. '\\n' .. table.concat(runTable(value), \"\")\n  else\n    value[3] = colorStr\n    resultStr = resultStr .. '\\n' .. table.concat(runTable(value), \"\") .. '  old Color: ' .. oldColorStr\n  end\n  __console.log(resultStr)\nend\n\nfor key, value in pairs(__console) do\n  console[key] = value\nend\nreturn console","@console.lua", "bt", _ENV)
end
do
package.preload["commander"] = load("-- 处理输入参数\nrequire 'string-split'\n\nlocal commander = {\n  keys = {},\n  params = {},\n}\n\nlocal optionKey = {}\n\ncommander.option = function(key, defaultValue)\n  key = key or ''\n  if type(key) == 'table' then\n  end\n  local optionObj = {\n    keys = {},\n    key = defaultValue,\n    defaultValue = defaultValue,\n  }\n  local keyArr = key:split(',')\n  for k, v in ipairs(keyArr) do\n    local theK = v:gsub('^%s*(.-)%s*$', '%1'):gsub('^-+', '')\n    optionObj.key = theKey\n    table.insert(optionObj.keys, theK)\n  end\n  for k, v in ipairs(optionObj.keys) do\n    optionKey[v] = optionObj\n  end\n  for k, v in ipairs(optionObj.keys) do\n    table.insert(commander.keys, v)\n  end\n  for k, v in ipairs(optionObj.keys) do\n    if defaultValue ~= nil then\n      commander.params[v] = defaultValue\n    end\n  end\n  return commander\nend\n\ncommander.parse = function(params)\n  params = params or {}\n  local i = 1\n  local paramsLength = #params\n  while i <= paramsLength do\n    if type(params[i]) == 'string' then\n      local theKey = params[i]:gsub('^%s*(.-)%s*$', '%1'):gsub('^-+', '')\n      if params[i]:gmatch('^-') and optionKey[theKey] then\n        local optionObj = optionKey[theKey]\n        local theParam = params[i + 1] ~= nil and params[i + 1] or true\n        for k, v in ipairs(optionObj.keys) do\n          commander.params[v] = theParam\n        end\n        i = i + 1\n      end\n    end\n    i = i + 1\n  end\n  return commander\nend\n\nreturn commander","@commander.lua", "bt", _ENV)
end

require("index")
